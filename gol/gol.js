// Generated by CoffeeScript 1.3.1
(function() {
  var draw, life;

  life = function(_arg) {
    var allPoints, birth, die, h, max, min, neighbours, node, nodes, range, tap, w;
    w = _arg.w, h = _arg.h, nodes = _arg.nodes;
    nodes || (nodes = []);
    nodes = nodes.reduce(function(all, node) {
      all["" + node.x + "," + node.y] = node;
      return all;
    }, {});
    range = function(start, end, increment) {
      var x, _i, _results;
      if (increment == null) {
        increment = 1;
      }
      _results = [];
      for (x = _i = start; start <= end ? _i <= end : _i >= end; x = _i += increment) {
        _results.push(x);
      }
      return _results;
    };
    min = Math.min, max = Math.max;
    allPoints = range(0, w).reduce(function(points, x) {
      range(0, h).forEach(function(y) {
        return points.push({
          x: x,
          y: y
        });
      });
      return points;
    }, []);
    tap = function(x) {
      console.log(x);
      return x;
    };
    node = function(_arg1) {
      var x, y;
      x = _arg1.x, y = _arg1.y;
      return nodes["" + x + "," + y];
    };
    die = function(point) {
      return delete nodes["" + point.x + "," + point.y];
    };
    birth = function(point) {
      return nodes["" + point.x + "," + point.y] = point;
    };
    neighbours = function(_arg1) {
      var x, y;
      x = _arg1.x, y = _arg1.y;
      return [-1, 0, 1].reduce(function(points, dx) {
        [-1, 0, 1].forEach(function(dy) {
          var candidate;
          candidate = {
            x: x + dx,
            y: y + dy
          };
          if ((dx !== 0 || dy !== 0) && node(candidate)) {
            return points.push(candidate);
          }
        });
        return points;
      }, []);
    };
    return function() {
      var newNodes, updated;
      newNodes = {};
      updated = allPoints.map(function(point) {
        var alive, coords, neighbourCount;
        neighbourCount = neighbours(point).length;
        coords = "" + point.x + "," + point.y;
        alive = nodes[coords] ? (1 < neighbourCount && neighbourCount < 4) : neighbourCount === 3;
        if (alive) {
          newNodes[coords] = point;
        }
        return {
          x: point.x,
          y: point.y,
          alive: alive
        };
      });
      nodes = newNodes;
      return updated;
    };
  };

  draw = function(_arg) {
    var cellDim, frame, gol, h, nodes, spaceship, svg, w;
    w = _arg.w, h = _arg.h, cellDim = _arg.cellDim;
    svg = d3.select("body").append("svg").attr({
      width: w,
      height: h
    });
    spaceship = [[2, 0], [2, 1], [2, 2], [1, 2], [0, 1]];
    nodes = spaceship.map(function(_arg1) {
      var x, y;
      x = _arg1[0], y = _arg1[1];
      return {
        x: x,
        y: y
      };
    });
    gol = life({
      w: 50,
      h: 50,
      nodes: nodes
    });
    frame = function() {
      var cells, data;
      data = gol();
      cells = svg.selectAll("rect").data(data, function(_arg1) {
        var x, y;
        x = _arg1.x, y = _arg1.y;
        return "" + x + "," + y;
      });
      cells.enter().append("rect").attr({
        width: cellDim,
        height: cellDim
      }).attr("transform", function(_arg1, i) {
        var x, y;
        x = _arg1.x, y = _arg1.y;
        return "translate(" + (x * cellDim) + "," + (y * cellDim) + ")";
      });
      return cells.attr("fill", function(point) {
        return (point.alive && "#FF0000") || "#000";
      });
    };
    return setInterval(frame, 500);
  };

  draw({
    w: document.body.clientWidth,
    h: document.body.clientHeight,
    cellDim: 15
  });

}).call(this);
